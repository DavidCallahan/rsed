%{
#include <string>
#include <iostream> 
#include "AST.h"
#include "Scanner.h"
#include "RegEx.h"
#include "BuiltinCalls.h"

int yylex(Scanner *);
void yyerror(Statement ** result, Scanner * scanner, const char * msg) {
  *result = nullptr;
  scanner->error() << msg << '\n';
}

void set_style(std::string *name,Scanner *scanner) {
   int err = RegEx::regEx->setStyle(*name);
   if(err) {
      scanner->error()  << "invalid regular expression style: "
      			 << *name << '\n'; 
   }
   delete name;
}

Expression * call(std::string * name, Arg * args, Scanner * scanner) {

    unsigned id = 0;
    bool ok = BuiltinCalls::getCallId(*name, &id);
    if (!ok) {
       scanner->error() << "invalid function name: " << *name << '\n';
    }
    auto c = new Call(*name, args, id, scanner->lineno());
    delete name;
    return c;
}

void checkTopExpr(Expression *top, Scanner * scanner) {
  auto msg = AST::checkTopExpression(top);
  if (msg != "" ){
      scanner->error() << msg << "\n";
  }
}
void checkPattern(Expression *pattern, Scanner * scanner) {
  auto msg = AST::checkPattern(pattern);
  if (msg != "") {
     scanner->error() << msg << "\n";
  }
}
#define LINE scanner->lineno()
#define BINARY(OP,x,y) new Binary(Binary::OP,x,y, LINE)
#define UNARY(OP,y) new Binary(Binary::OP, nullptr, y, LINE)

%}


%error-verbose

%union ParseResult {
  Statement * stmt;
  Expression * expr;
  Arg * arg;
  int token;
  std::string * name;
  int integer;
}

%token <name>  STRING VARIABLE IDENTIFIER
%token <token> FOREACH COPY SKIP TO PAST END NEWLINE REPLACE_TOK FOR SPLIT
%token <token> THEN ELSE IF NOT_TOK PRINT MATCH_TOK STYLE COLUMNS IN
%token <integer> NUMBER INPUT OUTPUT ERROR ALL WITH
%type <stmt> stmtlist stmt foreach copy skip replace 
%type <stmt> split print columns
%type <expr> control toPast stringExpr pattern call
%type <stmt> ifstmt elsestmt set input output errorStmt 
%type <expr> stringTerm string variable optControl optTopExpr
%type <expr>  predicate buffer optBuffer patternString topExpr
%type <arg> optarglist arglist 
%start script

%parse-param {Statement ** parseTree}
%parse-param {Scanner * scanner}
%lex-param {Scanner * scanner}
%nonassoc MATCH_TOK REPLACE_TOK

%%

script: optNewline optStyle stmtlist { *parseTree = $3 } ;

optNewline: /* empty*/ | NEWLINE ;

stmtlist: { $$ = AST::emptyStmt(); } | stmt stmtlist { $$ = Statement::list($1, $2); } ;

stmt: foreach | copy | skip | replace | ifstmt | split
    | set | print | input | output | errorStmt | columns
    ;


optStyle: /* empty */ | STYLE IDENTIFIER NEWLINE { set_style($2, scanner); } ;

foreach : FOREACH optControl NEWLINE stmtlist END NEWLINE
                { $$ = new Foreach($2, $4, LINE) ; }
optControl: /*empty*/ { $$ =AST::emptyExpr(); } | control ;

set: VARIABLE '=' topExpr NEWLINE { $$ = AST::set($1,$3); }
   ;

copy: COPY control NEWLINE { $$ = AST::copy($2); } ;

skip: SKIP control NEWLINE { $$ = AST::skip($2); } 
    | SKIP IF pattern NEWLINE  { $$ = AST::skipOne($3); }    // to end of foreach 
    | SKIP NEWLINE { $$ = AST::skip(); } ;  // skip 1

control: FOR NUMBER toPast  { $$ = AST::limit($2,$3); }
       | toPast  
       | FOR NUMBER	{ $$ = AST::limit($2); }
       | ALL { $$ = AST::all(); }
       ;

toPast: TO pattern  { $$ = AST::control(AST::StopAt, $2); }
      | PAST pattern { $$ = AST::control(AST::StopAfter, $2); } ;

replace: REPLACE_TOK pattern WITH topExpr control NEWLINE { $$ = AST::replace($5,$2,$4); }
       | REPLACE_TOK pattern WITH topExpr NEWLINE { $$ = AST::replaceOne($2,$4); }
       ;


split: SPLIT optTopExpr WITH pattern NEWLINE { $$ = new Split($4, $2, LINE); }
     ;
columns: SPLIT optTopExpr COLUMNS stringExpr NEWLINE { $$ = AST::columns($4, $2); }
       ;
optTopExpr: /* empty */ { $$ = nullptr; }
	  | topExpr     
          ;

// for use insode of foreach loops
ifstmt: IF predicate optThen NEWLINE stmtlist elsestmt END NEWLINE 
	{ $$ = AST::ifStmt($2, $5, $6);} 
	| IF stringExpr stmt { $$ = AST::ifGuard($2,$3); }
	;
optThen: /* empty */ | THEN  ;

elsestmt: /* empty */ { $$ = AST::emptyStmt() ; }
	| ELSE IF NEWLINE predicate optThen NEWLINE stmtlist elsestmt 
	  { $$ = AST::ifStmt($4, $7, $8); } 
	| ELSE NEWLINE stmtlist
	  { $$ = $3; } ;

print: PRINT topExpr optBuffer NEWLINE { $$ = AST::print($2,$3); };
errorStmt: ERROR topExpr NEWLINE { $$ = AST::error($2); };
optBuffer: /* empty */ { $$ = AST::emptyExpr(); } | TO buffer { $$ = $2; };

predicate: patternString;
pattern: patternString { $$ = $1; checkPattern($1,scanner); };
topExpr: patternString { $$ = $1; checkTopExpr($1,scanner); }
       | REPLACE_TOK pattern WITH stringExpr IN stringExpr {
         Arg *a = new Arg($6, nullptr, LINE);
         a = new Arg($4, a, LINE);
         a = new Arg($2, a, LINE);
         $$ = call(new std::string("sub"),a, scanner);
       }
       ;


patternString: stringExpr
       | stringExpr MATCH_TOK stringExpr { $$ = BINARY(MATCH, $1,$3); } 
       | NOT_TOK stringExpr { $$ = UNARY(NOT,$2); }
       ; 

stringExpr: stringTerm
	  | stringExpr  stringTerm  { $$ = BINARY(CONCAT,$1,$2); }
	  ;

stringTerm: variable
	  | string
	  | call
	  | NUMBER { $$ = AST::integer($1); }	  
	  | '(' patternString ')' { $$ = $2; }
	  ;

variable: VARIABLE { $$ = AST::variable($1); };
string:	  STRING   { $$ = AST::stringConst($1); };

call: IDENTIFIER '(' optarglist ')' { $$ = call($1, $3, scanner); }  
    ;


     
optarglist: /*empty*/ { $$ = nullptr; }
          | arglist 
	  ;
arglist: stringExpr { $$ = new Arg($1, nullptr ,LINE); }
       | stringExpr ',' arglist { $$ = new Arg($1, $3, LINE); }
       ;

input: INPUT buffer NEWLINE { $$ = AST::input($2); } ;
output: OUTPUT buffer NEWLINE { $$ = AST::output($2); } ;
buffer: stringExpr { $$ = AST::fileBuffer($1); } ;

%%