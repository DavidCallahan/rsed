%{
#include <string>
#include <iostream> 
#include "AST.h"
#include "Scanner.h"
#include "RegEx.h"
#include "BuiltinCalls.h"

int yylex(Scanner *);
void yyerror(Statement ** result, Scanner * scanner, const char * msg) {
  *result = nullptr;
  scanner->error() << msg << '\n';
}

void set_style(std::string *name,Scanner *scanner) {
   int err = RegEx::regEx->setStyle(*name);
   if(err) {
      scanner->error()  << "invalid regular expression style: "
      			 << *name << '\n'; 
   }
   delete name;
}

Expression * call(std::string * name, Expression * args, Scanner * scanner) {

    unsigned id = 0;
    bool ok = BuiltinCalls::getCallId(*name, &id);
    if (!ok) {
       scanner->error() << "invalid function name: " << *name << '\n';
    }
    return AST::call(name, args, id);
}

void checkTopExpr(Expression *top, Scanner * scanner) {
  auto msg = AST::checkTopExpression(top);
  if (msg != "" ){
      scanner->error() << msg << "\n";
  }
}
void checkPattern(Expression *pattern, Scanner * scanner) {
  auto msg = AST::checkPattern(pattern);
  if (msg != "") {
     scanner->error() << msg << "\n";
  }
}

%}


%error-verbose

%union ParseResult {
  Statement * stmt;
  Expression * expr;
  int token;
  std::string * name;
  int integer;
}

%token <name>  STRING VARIABLE IDENTIFIER
%token <token> FOREACH COPY SKIP TO PAST END NEWLINE REPLACE FOR
%token <token> THEN ELSE IF NOT PRINT MATCH STYLE COLUMNS IN
%token <integer> NUMBER INPUT OUTPUT ERROR ALL WITH
%type <stmt> stmtlist stmt foreach copy skip replace print columns
%type <expr> control toPast stringExpr pattern arglist optarglist call 
%type <stmt> ifstmt elsestmt set input output errorStmt 
%type <expr> stringTerm string variable optControl
%type <expr>  predicate buffer optBuffer patternString topExpr
%start script

%parse-param {Statement ** parseTree}
%parse-param {Scanner * scanner}
%lex-param {Scanner * scanner}
%nonassoc MATCH REPLACE

%%

script: optNewline optStyle stmtlist { *parseTree = $3 } ;

optNewline: /* empty*/ | NEWLINE ;

stmtlist: { $$ = AST::emptyStmt(); } | stmt stmtlist { $$ = AST::list($1, $2); } ;

stmt: foreach | copy | skip | replace | ifstmt 
    | set | print | input | output | errorStmt | columns
    ;


optStyle: /* empty */ | STYLE IDENTIFIER NEWLINE { set_style($2, scanner); } ;

foreach : FOREACH optControl NEWLINE stmtlist END NEWLINE  { $$ = AST::foreach($2, $4) ; }
optControl: /*empty*/ { $$ =AST::emptyExpr(); } | control ;

set: VARIABLE '=' topExpr NEWLINE { $$ = AST::set($1,$3); }
   ;

copy: COPY control NEWLINE { $$ = AST::copy($2); } ;

skip: SKIP control NEWLINE { $$ = AST::skip($2); } 
    | SKIP IF pattern NEWLINE  { $$ = AST::skipOne($3); }    // to end of foreach 
    | SKIP NEWLINE { $$ = AST::skip(); } ;  // skip 1

control: FOR NUMBER toPast  { $$ = AST::limit($2,$3); }
       | toPast  
       | FOR NUMBER	{ $$ = AST::limit($2); }
       | ALL { $$ = AST::all(); }
       ;

toPast: TO pattern  { $$ = AST::control(AST::StopAt, $2); }
      | PAST pattern { $$ = AST::control(AST::StopAfter, $2); } ;

replace: REPLACE pattern WITH topExpr control NEWLINE { $$ = AST::replace($5,$2,$4); }
       | REPLACE pattern WITH topExpr NEWLINE { $$ = AST::replaceOne($2,$4); }
       ;

// for use insode of foreach loops
ifstmt: IF predicate optThen NEWLINE stmtlist elsestmt END NEWLINE 
	{ $$ = AST::ifStmt($2, $5, $6);} 
	| IF stringExpr stmt { $$ = AST::ifGuard($2,$3); }
	;
optThen: /* empty */ | THEN  ;

elsestmt: /* empty */ { $$ = AST::emptyStmt() ; }
	| ELSE IF NEWLINE predicate optThen NEWLINE stmtlist elsestmt 
	  { $$ = AST::ifStmt($4, $7, $8); } 
	| ELSE NEWLINE stmtlist
	  { $$ = $3; } ;

print: PRINT topExpr optBuffer NEWLINE { $$ = AST::print($2,$3); };
errorStmt: ERROR topExpr NEWLINE { $$ = AST::error($2); };
optBuffer: /* empty */ { $$ = AST::emptyExpr(); } | TO buffer { $$ = $2; };

columns: COLUMNS stringExpr NEWLINE { $$ = AST::columns($2); } ;


predicate: patternString;
pattern: patternString { $$ = $1; checkPattern($1,scanner); };
topExpr: stringExpr { $$ = $1; checkTopExpr($1,scanner); }
       | REPLACE pattern WITH stringExpr IN stringExpr {	
       	   $$ = call(new std::string("sub"),
	   	     AST::list(AST::arg($2), 
	                       AST::list(AST::arg($4), AST::arg($6))),
		     scanner);
       }
       ;

patternString: stringExpr
       | stringExpr MATCH stringExpr { $$ = AST::match($1,$3); } 
       | NOT stringExpr { $$ = $2; }
       ; 

stringExpr: stringTerm
	  | stringExpr stringTerm  { $$ = AST::list($1, $2); }
	  ;

stringTerm: variable
	  | string
	  | call
	  | NUMBER { $$ = AST::integer($1); }	  
	  | '(' patternString ')' { $$ = $2; }
	  ;

variable: VARIABLE { $$ = AST::variable($1); };
string:	  STRING   { $$ = AST::stringConst($1); };

call: IDENTIFIER '(' optarglist ')' { $$ = call($1, $3, scanner); }  
    ;


     
optarglist: /*empty*/ { $$ = AST::emptyExpr(); }
          | arglist 
	  ;
arglist: stringExpr { $$ = AST::arg($1); } 
       | stringExpr ',' arglist { $$ = AST::list(AST::arg($1),$3); }
       ;

input: INPUT buffer NEWLINE { $$ = AST::input($2); } ;
output: OUTPUT buffer NEWLINE { $$ = AST::output($2); } ;
buffer: stringExpr { $$ = AST::fileBuffer($1); } ;

%%