%{
#include <string>
#include <iostream> 
#include "AST.h"
#include "Scanner.h"
#include "RegEx.h"
#include "BuiltinCalls.h"

int yylex(Scanner *);
void yyerror(Statement ** result, Scanner * scanner, const char * msg) {
  *result = nullptr;
  scanner->error() << msg << '\n';
}

void set_style(std::string *name,Scanner *scanner) {
   int err = RegEx::regEx->setStyle(*name);
   if(err) {
      scanner->error()  << "invalid regular expression style: "
      			 << *name << '\n'; 
   }
   delete name;
}

Expression * call(std::string * name, Arg * args, Scanner * scanner) {

    unsigned id = 0;
    bool ok = BuiltinCalls::getCallId(*name, &id);
    if (!ok) {
       scanner->error() << "invalid function name: " << *name << '\n';
    }
    auto c = new Call(*name, args, id, scanner->lineno());
    delete name;
    return c;
}

void checkTopExpr(Expression *top, Scanner * scanner) {
  auto msg = AST::checkTopExpression(top);
  if (msg != "" ){
      scanner->error() << msg << "\n";
  }
}
void checkPattern(Expression *pattern, Scanner * scanner) {
  auto msg = AST::checkPattern(pattern);
  if (msg != "") {
     scanner->error() << msg << "\n";
  }
}
#define LINE scanner->lineno()
#define BINARY(OP,x,y) new Binary(Binary::OP,x,y, LINE)
#define UNARY(OP,y) new Binary(Binary::OP, nullptr, y, LINE)

%}


%error-verbose

%union ParseResult {
  Statement * stmt;
  Expression * expr;
  Arg * arg;
  int token;
  std::string * name;
  int integer;
  bool boole;
}

%token <name>  STRING VARIABLE IDENTIFIER
%token <token> FOREACH COPY SKIP TO PAST END NEWLINE REPLACE_TOK FOR SPLIT
%token <token> THEN ELSE IF NOT_TOK PRINT MATCH_TOK STYLE 
%token <token> COLUMNS IN LOOKUP_START REQUIRED
%token <integer> NUMBER INPUT OUTPUT REWIND ERROR ALL WITH
%type <stmt> stmtlist stmt foreach copy skip replace 
%type <stmt> split print columns required
%type <expr> control toPast stringExpr pattern call lookup
%type <stmt> ifstmt elsestmt set input output rewind errorStmt 
%type <expr> stringTerm string variable optControl optTopExpr
%type <expr>  predicate buffer optBuffer patternString topExpr
%type <arg> optarglist arglist 
%type <boole> optAll optRequired
%type <expr> name
%type <integer> lineno
%start script

%parse-param {Statement ** parseTree}
%parse-param {Scanner * scanner}
%lex-param {Scanner * scanner}
%nonassoc MATCH_TOK REPLACE_TOK

%%

script: optNewline optStyle stmtlist { *parseTree = $3 } ;

// todo -- allow empty lines in more places
optNewline: /* empty*/ | NEWLINE ;
optStyle: /* empty */ | STYLE IDENTIFIER NEWLINE { set_style($2, scanner); } ;

stmtlist: { $$ = AST::emptyStmt(); } | stmt stmtlist { $$ = Statement::list($1, $2); } ;

stmt: foreach | copy | skip | replace | ifstmt | split
    | set | print | input | output | rewind | errorStmt | columns | required
    ;

foreach : FOREACH lineno optControl NEWLINE stmtlist END NEWLINE
                { $$ = new Foreach($3, $5, $2) ; }
optControl: /*empty*/ { $$ =AST::emptyExpr(); } | control ;
lineno: /* empty */ { $$ = LINE; };

set: name '=' topExpr NEWLINE { $$ = new Set($1,$3,LINE); };
name: variable 
    | lookup
    | IDENTIFIER { $$ = AST::variable($1); }
    ; 

copy: COPY lineno control NEWLINE { $$ = AST::copy($3,$2); } ;

skip: SKIP lineno control NEWLINE { $$ = AST::skip($3,$2); }
    | SKIP lineno IF pattern NEWLINE  { $$ = AST::skipOne($4, $2); }    // to end of foreach
    | SKIP NEWLINE { $$ = new Skip(LINE); } ;  // skip 1

control: FOR NUMBER toPast  { $$ = AST::limit($2,$3); }
       | toPast  
       | FOR NUMBER	{ $$ = AST::limit($2, LINE); }
       | ALL { $$ = AST::all(); }
       ;

toPast: TO optRequired pattern  { $$ = new Control(AST::StopAt, $3, $2,  LINE); }
      | PAST optRequired pattern { $$ = new Control(AST::StopAfter, $3,  $2, LINE); }
      ;
optRequired: /* empty */  { $$ = false; } 
           | REQUIRED  { $$ = true; }
	   ;

replace: REPLACE_TOK optAll pattern WITH topExpr control NEWLINE { $$ = AST::replace($6,$3,$5,$2,LINE); }
       | REPLACE_TOK optAll pattern WITH topExpr NEWLINE { $$ = AST::replaceOne($3,$5,$2,LINE); }
       ;
optAll: /* empty */ { $$ = false; } 
      | ALL { $$ = true; }
      ;


split: SPLIT optTopExpr WITH pattern NEWLINE { $$ = new Split($4, $2, LINE); } ;
columns: SPLIT optTopExpr COLUMNS stringExpr NEWLINE { $$ = new Columns($4, $2, LINE); }
optTopExpr: /* empty */ { $$ = nullptr; }
	  | topExpr     
          ;

// for use insode of foreach loops
ifstmt: IF predicate optThen NEWLINE stmtlist elsestmt END NEWLINE 
	{ $$ = new IfStatement($2, $5, $6, LINE);}
	| IF stringExpr stmt { $$ = new IfStatement($2,$3, nullptr, LINE); }
	;
optThen: /* empty */ | THEN  ;

elsestmt: /* empty */ { $$ = AST::emptyStmt() ; }
	| ELSE IF NEWLINE predicate optThen NEWLINE stmtlist elsestmt 
	  { $$ = new IfStatement($4, $7, $8, LINE); }
	| ELSE NEWLINE stmtlist
	  { $$ = $3; } ;

print: PRINT lineno topExpr optBuffer NEWLINE { $$ = new Print($3,$4, $2); };
errorStmt: ERROR lineno topExpr NEWLINE { $$ = new Error($3,$2); };
optBuffer: /* empty */ { $$ = AST::emptyExpr(); } | TO buffer { $$ = $2; };

required: REQUIRED lineno predicate NEWLINE { $$ = new Required(0, $3,$2); }

predicate: patternString;
pattern: patternString { $$ = $1; checkPattern($1,scanner); };
topExpr: patternString { $$ = $1; checkTopExpr($1,scanner); }
       | REPLACE_TOK optAll pattern WITH stringExpr IN stringExpr {
         Arg *a = new Arg($7, nullptr, LINE);
         a = new Arg($5, a, LINE);
         a = new Arg($3, a, LINE);
         $$ = call(new std::string($2 ? "suball" : "sub"),a, scanner);
       }
       ;


patternString: stringExpr
       | stringExpr MATCH_TOK stringExpr { $$ = BINARY(MATCH, $1,$3); } 
       | NOT_TOK patternString { $$ = UNARY(NOT,$2); }
       ; 

stringExpr: stringTerm
	  | stringExpr  stringTerm  { $$ = BINARY(CONCAT,$1,$2); }
	  ;

stringTerm: variable
	  | string
	  | lookup
	  | call
	  | NUMBER { $$ = AST::integer($1); }	  
	  | '(' patternString ')' { $$ = $2; }
	  ;
lookup: LOOKUP_START patternString ')' { $$ = UNARY(LOOKUP, $2); };

variable: VARIABLE { $$ = AST::variable($1); };
string:	  STRING   { $$ = AST::stringConst($1); };

call: IDENTIFIER '(' optarglist ')' { $$ = call($1, $3, scanner); }  
    ;


     
optarglist: /*empty*/ { $$ = nullptr; }
          | arglist 
	  ;
arglist: stringExpr { $$ = new Arg($1, nullptr ,LINE); }
       | stringExpr ',' arglist { $$ = new Arg($1, $3, LINE); }
       ;

input: INPUT lineno buffer NEWLINE { $$ = new Input($3,$2); }
output: OUTPUT lineno buffer NEWLINE { $$ = new Output($3,$2); }
rewind: REWIND lineno buffer NEWLINE { $$ = new Rewind($3,$2); }
buffer: stringExpr;
